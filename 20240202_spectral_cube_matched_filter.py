import numpy as np
import matplotlib.pyplot as plt
import os
import astropy.io.fits as fits
from glob import glob
from  scipy.interpolate import interp1d
import astropy.units as u
from astropy import constants as const
from copy import copy

from breads.instruments.jwstnirspec_cal import cube_matchedfilter

import matplotlib
matplotlib.use('Qt5Agg')



if __name__ == "__main__":
    try:
        import mkl
        mkl.set_num_threads(1)
    except:
        pass

    ####################
    ## To be modified
    ####################
    # Ouput dir for final figures and fits files
    out_png = "/stow/jruffio/data/JWST/nirspec/HD_19467/breads/figures"
    # External_dir should external files like the NIRCam filters
    external_dir = "/stow/jruffio/data/JWST/external/"
    # Filename of the files generated by 20240202_spectral_cubeish_extraction.py
    cube_filename_nrs1 = "/stow/jruffio/data/JWST/nirspec/HD_19467/breads/20240201_utils/jw01414004001_02101_nrs1_cube_RDI_20240202.fits"
    cube_filename_nrs2 = "/stow/jruffio/data/JWST/nirspec/HD_19467/breads/20240201_utils/jw01414004001_02101_nrs2_cube_RDI_20240202.fits"
    refcube_filename_nrs1 = "/stow/jruffio/data/JWST/nirspec/HD_19467/breads/20240201_utils/jw01414005001_02101_nrs1_cube_ref1_20240202.fits"
    refcube_filename_nrs2 = "/stow/jruffio/data/JWST/nirspec/HD_19467/breads/20240201_utils/jw01414005001_02101_nrs2_cube_ref1_20240202.fits"
    # Output filename
    out_filename_nrs1 = "/stow/jruffio/data/JWST/nirspec/HD_19467/breads/20240201_utils/jw01414004001_02101_nrs1_MF_RDI_20240202.fits"
    out_filename_nrs2 = "/stow/jruffio/data/JWST/nirspec/HD_19467/breads/20240201_utils/jw01414004001_02101_nrs2_MF_RDI_20240202.fits"
    out_ref_filename_nrs1 = "/stow/jruffio/data/JWST/nirspec/HD_19467/breads/20240201_utils/jw01414005001_02101_nrs1_MF_ref1_20240202.fits"
    out_ref_filename_nrs2 = "/stow/jruffio/data/JWST/nirspec/HD_19467/breads/20240201_utils/jw01414005001_02101_nrs2_MF_ref1_20240202.fits"
    # spectrum to be used for the companion template
    RDI_spec_filename = "/stow/jruffio/data/JWST/nirspec/HD_19467/breads/figures/HD19467b_RDI_1dspectrum_MJy.fits"
    # NIrcam filter used for flux normalization
    photfilter_name_nrs1 =  "F360M"
    photfilter_name_nrs2 =  "F460M"
    # RA Dec offset of the companion HD19467B
    ra_offset = -1332.871/1000. # ra offset in as
    dec_offset = -875.528/1000. # dec offset in as
        # Offsets for HD 19467 B from https://www.whereistheplanet.com/
        # RA Offset = -1332.871 +/- 10.886 mas
        # Dec Offset = -875.528 +/- 12.360 mas
        # Separation = 1593.703 +/- 9.530 mas
        # PA = 236.712 +/- 0.483 deg
        # Reference: Brandt et al. 2021
    HD19467_flux_MJy = {"F250M":3.51e-6, # in MJy, Ref Greenbaum+2023
                         "F300M":2.63e-6,
                         "F335M":2.10e-6,
                         "F360M":1.82e-6,
                         "F410M":1.49e-6,
                         "F430M":1.36e-6,
                         "F460M":1.12e-6}
    ROLL_REF0 = 65.01
    V3I_YANG = 138.97
    # Flux Calibration parameters
    flux_calib_paras = [-0.03864459,  1.09360589]
    ####################






    wvs = []
    HD19467B_spec = []
    # HD19467B_spec_hpferr = []
    HD19467B_spec_err = []
    HD19467B_spec_speckles = []
    for det_id, detector in enumerate(["nrs1","nrs2"]):
        if detector == "nrs1":
            # continue
            cube_filename = cube_filename_nrs1
            refcube_filename = refcube_filename_nrs1
            photfilter_name = photfilter_name_nrs1
            out_filename = out_filename_nrs1
            out_ref_filename = out_ref_filename_nrs1
        elif detector == "nrs2":
            cube_filename = cube_filename_nrs2
            refcube_filename = refcube_filename_nrs2
            photfilter_name = photfilter_name_nrs2
            out_filename = out_filename_nrs2
            out_ref_filename = out_ref_filename_nrs2

        if 1: #RDI template
            hdulist_sc = fits.open(RDI_spec_filename)
            RDI_spec_wvs = hdulist_sc[0].data
            RDI_spec = ((hdulist_sc[1].data * u.MJy) * (const.c / (RDI_spec_wvs * u.um) ** 2)).to(u.W * u.m ** -2 / u.um).value
            err = hdulist_sc[2].data

            photfilter = os.path.join(external_dir, "JWST_NIRCam." + photfilter_name + ".dat")
            filter_arr = np.loadtxt(photfilter)
            trans_wvs = filter_arr[:, 0] / 1e4
            trans = filter_arr[:, 1]
            photfilter_f = interp1d(trans_wvs, trans, bounds_error=False, fill_value=0)
            photfilter_wv0 = np.nansum(trans_wvs * photfilter_f(trans_wvs)) / np.nansum(photfilter_f(trans_wvs))
            bandpass = np.where(photfilter_f(trans_wvs) / np.nanmax(photfilter_f(trans_wvs)) > 0.01)
            photfilter_wvmin, photfilter_wvmax = trans_wvs[bandpass[0][0]], trans_wvs[bandpass[0][-1]]
            print(photfilter_wvmin, photfilter_wvmax)

            grid_dwvs = RDI_spec_wvs[1::] - RDI_spec_wvs[0:np.size(RDI_spec_wvs) - 1]
            grid_dwvs = np.insert(grid_dwvs, 0, grid_dwvs[0])
            filter_norm = np.nansum((grid_dwvs * u.um) * photfilter_f(RDI_spec_wvs))
            Flambda = np.nansum((grid_dwvs * u.um) * photfilter_f(RDI_spec_wvs) * (RDI_spec * u.W * u.m ** -2 / u.um)) / filter_norm
            Fnu = Flambda * (photfilter_wv0 * u.um) ** 2 / const.c  # from Flambda back to Fnu
            RDI_spec = RDI_spec / Fnu.to(u.MJy).value
            rv = 0
            planet_f = interp1d(RDI_spec_wvs,RDI_spec, bounds_error=False, fill_value=0)


        print(cube_filename)
        with fits.open(cube_filename) as hdulist:
            flux_cube = hdulist[0].data
            fluxerr_cube = hdulist['FLUXERR_CUBE'].data
            ra_grid = hdulist['RA'].data
            dec_grid = hdulist['DEC'].data
            wv_sampling = hdulist['WAVE'].data

        flux_cube = flux_cube*np.polyval(flux_calib_paras, wv_sampling)[:,None,None]
        fluxerr_cube = fluxerr_cube*np.polyval(flux_calib_paras, wv_sampling)[:,None,None]

        if 1:  # Mask the bar from the charge diffusion
            threshold2mask = 0.15
            ny, nx = ra_grid.shape
            bleeding_axis_slope = np.tan(np.deg2rad(+ROLL_REF0+V3I_YANG))
            distances2bleeding = np.abs(ra_grid - bleeding_axis_slope * dec_grid) / np.sqrt(1 + bleeding_axis_slope ** 2)
            # Find the indices of the points within the threshold distance
            where2mask = np.where(distances2bleeding < threshold2mask)
            flux_cube[:,where2mask[0],where2mask[1]] = np.nan
            fluxerr_cube[:,where2mask[0],where2mask[1]] = np.nan

        print(refcube_filename)
        with fits.open(refcube_filename) as hdulist:
            flux_cube_ref = hdulist[0].data
            fluxerr_cube_ref = hdulist['FLUXERR_CUBE'].data
            ra_grid_ref = hdulist['RA'].data
            dec_grid_ref = hdulist['DEC'].data
            wv_sampling_ref = hdulist['WAVE'].data

        flux_cube_ref = flux_cube_ref * np.polyval(flux_calib_paras, wv_sampling)[:, None, None]
        fluxerr_cube_ref = fluxerr_cube_ref * np.polyval(flux_calib_paras, wv_sampling)[:, None, None]

        if 1:  # Mask the bar from the charge diffusion
            threshold2mask = 0.2
            ny, nx = ra_grid_ref.shape
            bleeding_axis_slope = np.tan(np.deg2rad(+ROLL_REF0+V3I_YANG))
            distances2bleeding = np.abs(ra_grid_ref - bleeding_axis_slope * dec_grid_ref) / np.sqrt(1 + bleeding_axis_slope ** 2)
            # Find the indices of the points within the threshold distance
            where2mask = np.where(distances2bleeding < threshold2mask)
            flux_cube_ref[:,where2mask[0],where2mask[1]] = np.nan
            fluxerr_cube_ref[:,where2mask[0],where2mask[1]] = np.nan

        #######################################
        ## matched filtering
        # plt.plot(wv_sampling, planet_f(wv_sampling))
        # plt.show()
        if 1:
            out_mf = cube_matchedfilter(flux_cube,fluxerr_cube,wv_sampling,ra_grid, dec_grid,planet_f, rv=0,out_filename=out_filename,outlier_threshold=10)
            snr_map, flux_map, fluxerr_map, ra_grid, dec_grid = out_mf

            out_mf = cube_matchedfilter(flux_cube_ref,fluxerr_cube_ref,wv_sampling_ref,ra_grid_ref, dec_grid_ref,planet_f, rv=0,out_filename=out_ref_filename,outlier_threshold=10)
            snr_map_ref, flux_map_ref, fluxerr_map_ref, ra_grid_ref, dec_grid_ref = out_mf
        else:
            with fits.open(out_filename) as hdulist:
                flux_map = hdulist[0].data
                fluxerr_map = hdulist['FLUXERR'].data
                snr_map = hdulist['SNR'].data
                ra_grid = hdulist['RA'].data
                dec_grid = hdulist['DEC'].data
            with fits.open(out_ref_filename) as hdulist:
                flux_map_ref = hdulist[0].data
                fluxerr_map_ref = hdulist['FLUXERR'].data
                snr_map_ref = hdulist['SNR'].data
                ra_grid_ref = hdulist['RA'].data
                dec_grid_ref = hdulist['DEC'].data
        #######################################

        snr_map[np.where(~np.isfinite(snr_map))] = np.nan

        kmax, lmax = np.unravel_index(np.nanargmax(flux_map * (((ra_grid - ra_offset) ** 2 + (dec_grid - dec_offset) ** 2) < 0.4)), flux_map.shape)
        print(kmax, lmax, ra_grid[kmax, lmax], dec_grid[kmax, lmax])
        r2comp_grid = np.sqrt((ra_grid - ra_grid[kmax, lmax]) ** 2 + (dec_grid - dec_grid[kmax, lmax]) ** 2)
        r2star_grid = np.sqrt((ra_grid) ** 2 + (dec_grid) ** 2)

        if 1:
            snr_scaling = np.nanstd(snr_map[np.where(r2comp_grid > 0.3)])
            snr_map2 = snr_map/ snr_scaling
            fluxerr_map = fluxerr_map*snr_scaling
        else:# assuming error is systematics limited, meaning error proportional to speckle intensity
            im_err_2 = np.sqrt(np.nansum(flux_cube_ref ** 2, axis=0)) / flux_cube_ref.shape[0]
            snr_map2 = flux_map / flux_map_ref
            snr_map2 = snr_map2 / np.nanstd(snr_map2[np.where(r2comp_grid > 0.3)])

        if 1: # Save invididual maps
            out_filename = os.path.join(out_png, "HD19467B_RDI_" + photfilter_name + "_" + detector + "_SNR.fits")
            hdulist = fits.HDUList()
            hdulist.append(fits.PrimaryHDU(data=snr_map2))
            try:
                hdulist.writeto(out_filename, overwrite=True)
            except TypeError:
                hdulist.writeto(out_filename, clobber=True)
            hdulist.close()

            out_filename = os.path.join(out_png, "HD19467B_RDI_" + photfilter_name + "_" + detector + "_flux.fits")
            hdulist = fits.HDUList()
            hdulist.append(fits.PrimaryHDU(data=flux_map))
            try:
                hdulist.writeto(out_filename, overwrite=True)
            except TypeError:
                hdulist.writeto(out_filename, clobber=True)
            hdulist.close()

            out_filename = os.path.join(out_png, "HD19467B_RDI_" + photfilter_name + "_" + detector + "_fluxerr.fits")
            hdulist = fits.HDUList()
            hdulist.append(fits.PrimaryHDU(data=fluxerr_map))
            try:
                hdulist.writeto(out_filename, overwrite=True)
            except TypeError:
                hdulist.writeto(out_filename, clobber=True)
            hdulist.close()

            out_filename = os.path.join(out_png,
                                        "HD19467B_RDI_" + photfilter_name + "_" + detector + "_fluxratioerr_1sig.fits")
            hdulist = fits.HDUList()
            hdulist.append(fits.PrimaryHDU(data=fluxerr_map / HD19467_flux_MJy[photfilter_name]))
            try:
                hdulist.writeto(out_filename, overwrite=True)
            except TypeError:
                hdulist.writeto(out_filename, clobber=True)
            hdulist.close()

            out_filename = os.path.join(out_png, "HD19467B_RDI_" + photfilter_name + "_" + detector + "_RADec.fits")
            hdulist = fits.HDUList()
            hdulist.append(fits.PrimaryHDU(data=ra_grid))
            hdulist.append(fits.ImageHDU(data=dec_grid))
            try:
                hdulist.writeto(out_filename, overwrite=True)
            except TypeError:
                hdulist.writeto(out_filename, clobber=True)
            hdulist.close()

        plt.figure(1 + det_id*3)
        plt.subplot(1, 3, 1)
        plt.title(photfilter_name + " " + detector + " Flux (MJy)")
        plt.imshow(flux_map, origin="lower")
        plt.clim([-1e-10, 1e-10])
        plt.colorbar()
        plt.subplot(1, 3, 3)
        plt.title(photfilter_name + " " + detector + " S/N")
        plt.imshow(snr_map2, origin="lower")
        plt.clim([-3, 5])
        plt.colorbar()
        plt.subplot(1, 3, 2)
        fluxerr_map = flux_map / snr_map2
        plt.title(photfilter_name + " " + detector + " 1sigma Error (MJy)")
        plt.imshow(fluxerr_map, origin="lower")
        plt.clim([-1e-10, 1e-10])
        plt.colorbar()

        plt.figure(2+det_id*3)
        sep = r2star_grid[np.where(r2comp_grid > 0.3)]
        contrast_5sig = 5 * fluxerr_map[np.where(r2comp_grid > 0.3)] / HD19467_flux_MJy[photfilter_name]
        plt.scatter(sep, contrast_5sig, s=5, alpha=0.2, label=photfilter_name + " NIRSpec " + detector)
        plt.yscale("log")
        plt.xlim([0, 3])
        plt.xlabel("Separation (as)")
        plt.ylabel("Flux ratio (5 sig)")
        plt.legend()

        plt.figure(3+det_id*3)
        snr_map_masked = copy(snr_map2)
        snr_map_masked[np.where((r2comp_grid < 0.3))] = np.nan

        # Create a histogram using the hist function from NumPy
        hist, bins = np.histogram(snr_map_masked[np.where(np.isfinite(snr_map_masked))], bins=20 * 3,
                                  range=(-10, 10))  # , bins=256, range=(0, 256)
        bin_centers = (bins[1::] + bins[0:np.size(bins) - 1]) / 2.
        plt.plot(bin_centers, hist / (np.nansum(hist) * (bins[1] - bins[0])), label="snr map")
        plt.plot(bin_centers, 1 / np.sqrt(2 * np.pi) * np.exp(-0.5 * (bin_centers - 0.0) ** 2), color="black",
                 linestyle="--", label="Gaussian")
        plt.yscale("log")
        plt.ylim([1e-4, 1])
        plt.legend()

    plt.show()
